<!-- <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>

    <style type='text/css'>
    
        #testo{
            position:absolute;
            background-color: #949090;
        }
    
    </style>
    
</head>
<body>
    <script src="js/three.js"></script>
    <script src="js/GLTFLoader.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/inflate.min.js"></script>
    <script src="js/FBXLoader.js"></script>
    
    <div id="testo">
        <p></p>
        <input id="bottoneSu" type="button" value="su" onmousedown="alza()">
        <input id="bottoneDestra" type="button" value="destra" onmousedown="destra()">
        <input id="bottoneGiu" type="button" value="giu" onmousedown="abbassa()">
        <input id="bottoneSinistra" type="button" value="sinistra" onmousedown="sinistra()">
    </div>
    
    
    <script>    
    var scene, camera, renderer, mesh, raycaster, base, braccio1, braccio2, coso, mano, soggetto, mat, controllo;
    var mouse = new THREE.Vector2();
    var testo = document.getElementById("testo");
    var s = "", st = "";
    var pannelliScomparsa = new Array();
    var modello = new Map(), arrayModello = new Array(), arrayAngoli = new Array();
    var puntoInt;
    // let i;

    var event = new CustomEvent("nomone", {detail: 3});


    var material = new THREE.MeshNormalMaterial();
    
    //######FLAG######
    var elementoCaricato = false, dirBraccio2 = true, flagVisibilitaPannelli = new Array();

    init();
    function init(){
        //GUARDA CREATE EVENT


        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xECF8FF);

        //######CAMERA######
        camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 1, 1000);
        camera.position.set(4, 4, 8);
        camera.lookAt(0,0,0);

        //######LUCI######
        var light = new THREE.PointLight( 0xffffff, 1, 100 );
        light.position.set( 5, 5, 5 );
        scene.add( light );

        //######CONTROLLI######
        controllo = new THREE.OrbitControls(camera);
        controllo.enableZoom = true;
        controllo.enablePan = false;


        //######HELPER######
        // var assi = new THREE.AxesHelper( 100 );
        // scene.add(assi);   
        

        //######CARICO MODELLO######
        // var loader = new THREE.GLTFLoader();
        // var FBXLoader = require('three-fbx-loader');
        var loader = new THREE.JSONLoader();
        loader.load('Modelli/braccioV4.json', function( fbx, a){
            
            // base = fbx.scene.children[0];
            // // base.material = new THREE.MeshToonMaterial({color: 0x000000});
            
            // braccio1 = base.children[0];
            // // braccio1.material = new THREE.MeshToonMaterial({color: 0x000000});
            
            // braccio2 = braccio1.children[0];
            // // braccio2.material = new THREE.MeshToonMaterial({color: 0x000000});
            
            // coso = braccio1.children[1];
            // // coso.material = new THREE.MeshToonMaterial({color: 0x000000});
            
            // mano = braccio2.children[0];
            // mano.material = new THREE.MeshToonMaterial({color: 0x000000});
            
            
            // percorsoAlberoRicorsivo(0, gltf.scene.children[0]);
            
            scene.add(fbx);
            base.position.x = 0;
            base.position.y = 0;
            base.position.z = 0;
            
            elementoCaricato = true;
        }, undefined, function(error){
            console.log(error);
        });

        //######RENDER######
        glRenderer = new THREE.WebGLRenderer({antialias: true});
        glRenderer.setPixelRatio(window.devicePixelRatio);
        glRenderer.setSize(window.innerWidth, window.innerHeight);
        
        raycaster = new THREE.Raycaster();
        
        document.addEventListener("mqttSignal", function(e){console.log(e.detail)});
        document.addEventListener('mousemove', onMouseMove, false);//puo essere utilizzato solo su dom, per le mesh devo usare raycaste
        // document.addEventListener('mousedown', onmousedown, false);
        // document.addEventListener('mouseup', onmouseup, false);
        window.addEventListener( 'resize', onWindowResize, false );
        
        //l'ultimo elemento e' il bubbling(false) o casting(true)
        document.body.appendChild(glRenderer.domElement);
        // glRenderer.domElement.addEventListener('click', onmouseclick);

    }


    function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		glRenderer.setSize( window.innerWidth, window.innerHeight );
	}


    var Abase = 0, ABraccio2 = 0, Acoso = 0;
    //angolo pistone = 0.29077*sin(180-aBraccio2)/(3.14296 - cos(180-ABraccio2))
    animate();


    function animate(){
        // if(elementoCaricato){
        //     for(i = 0; i<arrayModello.length; i++){
        //         //SETTO TUTTI GLI ANGOLI
        //     }
        // }
        if(elementoCaricato){
            // base.rotation.y = Abase;
            // braccio2.rotation.x = Math.PI/8;    
            // coso.rotation.x = Acoso;
            console.log(coso.rotation.x);
        }
        
        render();
        requestAnimationFrame(animate);
    }


    function render(){
        camera.updateMatrixWorld();
        raycaster.setFromCamera( mouse, camera );
        
        //##########RAYCASTER###############
        // var intersects = raycaster.intersectObjects( scene.children, true );
        // s = st;
        // if(intersects.length > 0){
        //     if(intersects[0].object != soggetto){
        //         if(soggetto!=null) soggetto.material = mat;
        //         soggetto = intersects[0].object;
        //         puntoInt = intersects[0].point;
        //         mat = soggetto.material;
        //         if(soggetto.name != "pannello") soggetto.material = new THREE.MeshPhysicalMaterial({color: 0xff0000});
        //         st = soggetto.name;
        //     }
        //     // s += "rilevato"
        // } else {
        //     if (mat!=undefined) if(soggetto!=null) soggetto.material = mat;
        //     soggetto = null;
        //     // s += "niente";
        // }
        //##################################

        glRenderer.render(scene, camera);
        // testo.children[0].textContent = s;
    }

    function onMqttSignal(e){
        arrayAngoli = e.detail;
    }

    // var flagiIsPressed = false;
    // var previousMouse = new THREE.Vector2(0, 0);
    // var deltaMove = new THREE.Vector2();
    // function onmousedown(){
    //     flagiIsPressed = true;
    // }

    function onMouseMove( event ){

        event.preventDefault();

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        // deltaMove.x = event.offsetX - previousMouse.x;
        // deltaMove.y = event.offsetY - previousMouse.y;

        // if(flagiIsPressed){
        //     var deltaRotationQuaternion = new THREE.Quaternion()
        //     .setFromEuler(new THREE.Euler(
        //         deltaMove.y*2*3.14/360,
        //         deltaMove.x*2*3.14/360,
        //         0,
        //         'XYZ'
        //     ));
        
        //     // console.log(deltaMove);
        //     base.quaternion.multiplyQuaternions(deltaRotationQuaternion, base.quaternion);
        // }

        // previousMouse.x = event.offsetX;
        // previousMouse.y = event.offsetY;
        // st= "asse X ->" + event.clientX + " " + mouse.x + "\n" +"asse Y ->" + event.clientY + " " + mouse.y + "\n";
    }

    function onmouseup(){
        flagiIsPressed = false;
    }

    var v;
    function onmouseclick(){

        if((soggetto != undefined)&&(soggetto!=null)){
            
            if((v = modello.get(soggetto)) != undefined){
                v.position.x = puntoInt.x + v.scale.x/2;
                v.position.y = puntoInt.y + v.scale.y/2;
                v.position.z = puntoInt.z;
                v.visible = !v.visible;
                // console.log(v.matrixWorld);
                // console.log(camera.matrixWorld);


                // function time(){
                //     var l = v;
                //     setTimeout(function(){l.visible = false;}, 3000);
                // }
                // time();

                // window.setTimeout(function(l = v){l.visible = false;}, 6000);
            } else if (soggetto.name == "pannello") {
                soggetto.visible = false;
            }
            // v = modello.get(soggetto);
            // modello.get(soggetto).visible =! modello.get(soggetto).visible;
            
            console.log(puntoInt);


            
        }
       
    }

    //##############################
    //##############################

    //##############################
    //#########RICORSIONE###########
    //##############################
    
    var pannello;
    function percorsoAlberoRicorsivo(i, p){

        arrayModello[i] = p;
        arrayAngoli[i] = 0;
        // scene.add(p);
        // modello[i].material = new THREE.MeshToonMaterial({color: 0x000000});
        
        pannello = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), material);
        pannello.name = "pannello";
        pannello.visible = false;

        modello.set(p, pannello);
        modello[i] = p;

        // pannelliScomparsa[i] = new THREE.Mesh(new THREE.PlaneGeometry(2, 5), material);
        // flagVisibilitaPannelli[i] = false;
        // pannelliScomparsa[i].visible = flagVisibilitaPannelli[i];

        scene.add(pannello);
        
        var o;
        for(o = 0; p.children[o]!=undefined; o++){
            percorsoAlberoRicorsivo(i + 1, p.children[o]);
        }
    }


    // var c1 = 1.981584, c2 = 0.577036, i = 1.783922, s = 0;
    function alza(){
        if(ABraccio2 < 3.14/4)ABraccio2 += 0.02;
        // i = c1^2 + c2^2 - 2*c1*c2*Math.cos(Math.PI/2 - ABraccio2 - 0.1625630392598);
        
        // Acoso = Math.asin(c2/i * Math.sin(Math.PI/2 - ABraccio2 - 0.1625630392598));
        // Acoso = 0;
    }

    function abbassa(){
        if(ABraccio2 > -3.14/4) ABraccio2 -= 0.02;
        // Acoso = Math.asin(c2*Math.sin(Math.PI - ABraccio2)/(c1^2 + c2^2 - 2*c1*c2*Math.cos(Math.PI - ABraccio2)));
        // Acoso = 0;
    }

    function destra(){
        Abase += 0.02;
    }

    function sinistra(){
        Abase -= 0.02;
    }
    </script>
    
</body>
</html> -->



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

    <script src="js/three.js"></script>

    <script>
    
    var camera, scene, renderer;

    init();
    function init(){

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xECF8FF);

        camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 1, 1000);
        camera.position.set(5, 5, 5);
        camera.lookAt(0,0,0);

        var light = new THREE.PointLight( 0xffffff, 1, 100 );
        light.position.set( 5, 5, 5 );
        scene.add( light );

        var assi = new THREE.AxesHelper( 100 );
        scene.add(assi);

        var Gcubo = new THREE.BoxGeometry(1, 4, 8);
        var material = new THREE.MeshPhysicalMaterial({color: 0x00ff00});
        var cubo = new THREE.Mesh(Gcubo, material);
        // cubo.lookAt(0, 1, 0);
        scene.add(cubo);


        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        window.addEventListener( 'resize', onWindowResize, false );
        
        animate();
    } 

    function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}


    function animate(){

        render();
        requestAnimationFrame(render);
    }

    function render(){
        renderer.render(scene, camera);  
    }
    
    
    </script>
    
</body>
</html>